/* Source - https://leetcode.com/problems/minimize-malware-spread/
   Author - Shivam Arora
*/
#include <bits/stdc++.h>
using namespace std;

void connectedComps(int src, vector<vector<int>>& graph, bool *visited, unordered_set<int>& single) {
    visited[src] = true;
    
    single.insert(src);
    
    for(int i = 0; i < graph[src].size(); i++) {
        if(!visited[i] && graph[src][i] == 1)
            connectedComps(i, graph, visited, single);
    }
}

// approach 1
int minMalwareSpreadUsingDFS(vector<vector<int>>& graph, vector<int>& initial) {
    int n = graph.size();
    bool visited[n];
    
    memset(visited, false, sizeof(visited));
    
    int infCount, infected, maxSaved = -1, remove = -1; 
    
    for(int i = 0; i < n; i++) {
        if(!visited[i]) {
            unordered_set<int> single;
            connectedComps(i, graph, visited, single);
                
            infCount = 0, infected = INT_MAX;
                
            for(int j = 0; j < initial.size(); j++) {
                if(single.find(initial[j]) != single.end()) { 
                    infCount++;
                    
                    if(initial[j] < infected)
                        infected = initial[j];
                }
            }
                                                                        
            if(infCount == 1) {
                int saved = single.size() - infCount;
                
                if(saved > maxSaved) {
                    maxSaved = saved;
                    remove = infected;
                }
            } else if(remove == -1)
                remove = infected;
        }
    }
    
    return remove;
}

int dsFind(int i, int* parent) {
    if(i == parent[i])
        return i;
    else {
        int result = dsFind(parent[i], parent);
        parent[i] = result;
        
        return result;
    }
}

void dsUnion(int x, int y, int* parent, int* size) {
    int px = dsFind(x, parent);
    int py = dsFind(y, parent);
    
    if(px != py) {
        if(size[px] < size[py]) {
            parent[px] = py;
            size[py] += size[px];
        } else if(size[px] > size[py]) {
            parent[py] = px;
            size[px] += size[py];
        } else {
            parent[py] = px;
            size[px] += size[py];
        }
    }
}

// approach 2
int minMalwareSpreadUsingDSU(vector<vector<int>>& graph, vector<int>& initial) {
    int n = graph.size();
    int parent[n], size[n];
    
    for(int i = 0; i < n; i++) {
        parent[i] = i;
        size[i] = 1;
    }
    
    for(int i = 0; i < graph.size(); i++) {
        for(int j = 0; j < graph[i].size(); j++) {
            if(j != i && graph[i][j] == 1)
                dsUnion(i, j, parent, size);
        }
    }
    
    unordered_map<int, int> infCount;
    
    for(int i = 0; i < initial.size(); i++) {
        int p = dsFind(initial[i], parent);
        infCount[p]++;
    }
    
    int maxSize = 0, remove = INT_MAX;
    
    for(int i = 0; i < initial.size(); i++) {
        int p = dsFind(initial[i], parent);
        
        if(infCount[p] == 1 && size[p] >= maxSize) {
            maxSize = size[p];
            remove = min(remove, initial[i]);
        }
    }
    
    return remove == INT_MAX ? *min_element(initial.begin(), initial.end()) : remove;
}

int main()
{
    int n;

    cout<<"Enter number of vertices: ";
    cin>>n;

    vector<vector<int>> graph(n, vector<int> (n));

    cout<<"Enter values for each node (1 for self, 1 - if there's an edge, 0 - if no edge): "<<endl;
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++)
            cin>>graph[i][j];
    }

    int c;

    cout<<"Enter number of infected nodes: ";
    cin>>n;

    vector<int> initial(c);

    cout<<"Enter infected nodes: ";
    for(int i = 0; i < c; i++)
        cin>>initial[i];

    cout<<"Infected node that can be removed to minimise malware spread (using DFS): "<<minMalwareSpreadUsingDFS(graph, initial)<<endl;
    cout<<"Infected node that can be removed to minimise malware spread (using DSU): "<<minMalwareSpreadUsingDSU(graph, initial)<<endl;
}